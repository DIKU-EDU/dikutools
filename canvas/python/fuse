#!/usr/bin/env python3

import sys
import os
import errno
import stat
import time

import llfuse

from canvas import *


DIRECTORY, FILE = range(1, 3)

def directory_entry():
    entry = llfuse.EntryAttributes()

    entry.st_mode = (stat.S_IFDIR | 0o755)
    entry.st_size = 0

    stamp = int(1438467123.985654 * 1e9)
    entry.st_atime_ns = stamp
    entry.st_ctime_ns = stamp
    entry.st_mtime_ns = stamp
    entry.st_gid = os.getgid()
    entry.st_uid = os.getuid()
    # entry.st_ino = set later

    return entry

def file_entry(size):
    entry = llfuse.EntryAttributes()

    entry.st_mode = (stat.S_IFREG | 0o644)
    entry.st_size = size

    stamp = int(1438467123.985654 * 1e9)
    entry.st_atime_ns = stamp
    entry.st_ctime_ns = stamp
    entry.st_mtime_ns = stamp
    entry.st_gid = os.getgid()
    entry.st_uid = os.getuid()
    # entry.st_ino = set later

    return entry

def set_inode(entry, inode):
    entry.st_ino = inode

def join_paths(*paths):
    path = '/'.join(paths)
    if path.startswith('/'):
        path = path[1:]
    return path

def inf_range(start=0):
    i = start;
    while True:
        yield i
        i += 1

# TODO: Make something better.
cached_data = {}
def cache(name, data_fun, expiration_time=None):
    if expiration_time is None:
        expiration_time = time.time() + 60 * 60

    try:
        block = cached_data[name]
    except KeyError:
        data = data_fun()
        cached_data[name] = (data, expiration_time)
        return data
    else:
        data_r, expiration_time_r = block
        if time.time() > expiration_time_r:
            del cached_data[name]
            return cache(name, data_fun, expiration_time)
        else:
            return data_r

class CanvasFS(llfuse.Operations):
    def __init__(self, canvas):
        super(CanvasFS, self).__init__()
        self.canvas = canvas

        self.inodes = [(llfuse.ROOT_INODE, '')]

    def find_path(self, this_inode):
        for inode, path in self.inodes:
            if inode == this_inode:
                return path

    def find_inode(self, this_path):
        for inode, path in self.inodes:
            if path == this_path:
                return inode

        inode = llfuse.ROOT_INODE + len(self.inodes)
        self.inodes.append((inode, this_path))
        return inode

    def get_contents(self, path):
        print('###### get_contents({})'.format(repr(path)))
        if path == '':
            return self.root()
        elif path == 'courses':
            return self.courses()
        elif path.startswith('courses/'):
            sub_path = path.split('/', 1)[1]
            return self.course(sub_path)
        else:
            raise llfuse.FUSEError(errno.ENOENT)

    def root(self):
        yield DIRECTORY
        yield directory_entry()
        yield 'courses'

    def courses(self):
        yield DIRECTORY
        yield directory_entry()

        course_ids = cache('courses',
                           lambda: [str(course['id']) for course
                                    in self.canvas.courses()])
        yield from course_ids

    def course(self, sub_path):
        parts = sub_path.split('/')
        course_id = parts[0]
        if len(parts) == 1:
            yield DIRECTORY
            yield directory_entry()
            yield 'name'
        elif len(parts) == 2:
            if parts[1] == 'name':
                course = cache(('course', course_id),
                               lambda: self.canvas.course(course_id))
                data = course['name'].encode('utf-8') + b'\n'
                yield FILE
                yield file_entry(len(data))
                yield data

    def getattr(self, inode, ctx=None):
        path = self.find_path(inode)
        contents = self.get_contents(path)
        typ = next(contents)
        entry = next(contents)
        set_inode(entry, inode)

        return entry

    def lookup(self, parent_inode, name, ctx=None):
        path = join_paths(self.find_path(parent_inode),
                          name.decode('utf-8'))
        inode = self.find_inode(path)
        return self.getattr(inode)

    def opendir(self, inode, ctx):
        path = self.find_path(inode)
        if path is None or next(self.get_contents(path)) != DIRECTORY:
            raise llfuse.FUSEError(errno.ENOENT)
        return inode

    def readdir(self, fh, off):
        path = self.find_path(fh)
        contents = self.get_contents(path)
        typ = next(contents)
        attr = next(contents)
        set_inode(attr, fh)

        for name, i in zip(contents, inf_range()):
            if i == off:
                c_path = join_paths(path, name)
                c_inode = self.find_inode(c_path)
                c_contents = self.get_contents(c_path)
                c_typ = next(c_contents)
                c_attr = next(c_contents)
                set_inode(c_attr, c_inode)
                yield (name.encode('utf-8'), c_attr, i + 1)

    def open(self, inode, flags, ctx):
        path = self.find_path(inode)
        if path is None or next(self.get_contents(path)) != FILE:
            raise llfuse.FUSEError(errno.ENOENT)
        return inode

    def read(self, fh, off, size):
        path = self.find_path(fh)
        contents = self.get_contents(path)
        typ = next(contents)
        attr = next(contents)
        data = next(contents)
        set_inode(attr, fh)

        return data[off:off + size]

def main(args):
    try:
        [mountpoint] = args
    except ValueError:
        print('error: wrong arguments', file=sys.stderr)
        print('usage: fuse MOUNTPOINT',
              file=sys.stderr)
        return 1

    fs = CanvasFS(Canvas())
    fuse_options = set(llfuse.default_options)
    fuse_options.add('fsname=canvas')
    fuse_options.add('debug')
    llfuse.init(fs, mountpoint, fuse_options)

    try:
        llfuse.main(workers=1)
    except:
        llfuse.close(unmount=False)
        raise

    llfuse.close()
    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
