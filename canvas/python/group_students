#!/usr/bin/env python3

import sys
import re

from canvas import *


def main(args):
    try:
        [course_id, ass_group_name, group_file] = args
    except ValueError:
        print('error: wrong arguments', file=sys.stderr)
        print('usage: group_students COURSE_ID ASSIGNMENT_GROUP_NAME GROUP_FILE',
              file=sys.stderr)
        return 1

    with open(group_file) as f:
        groups = [line.split(' ') for line in f.read().strip().split('\n')]

    c = Canvas()
    group_cats = c.group_categories(course_id)
    group_cat = next(filter(lambda c: c['name'] == ass_group_name,
                            group_cats))
    group_cat_id = group_cat['id']

    students = c.all_students(course_id)

    # Mapping from abc123 (or whatever is before @ in the KU email address) to
    # user id.
    user_login_ids = {}
    for s in students:
        m = re.match('^(.+?)@', s['login_id'])
        user_login_ids[m.group(1)] = s['id']

    # The groups text file can contain all groups, some of them single-person
    # groups, and some of them KU ids for people who haven't submitted at all.
    # To keep things simple, we only create Absalon groups for groups of size 2
    # or more.  Otherwise, we might end up creating a group for a student who
    # hadn't yet submitted, and who would end up in a group later on, which
    # would require a new group or a change to the existing group.  So: Keep it
    # simple!
    groups = list(filter(lambda g: len(g) >= 2, groups))
    for users, i in zip(groups, range(0, len(groups))):
        name = '{} {:03d}'.format(ass_group_name, i)
        users = list(map(lambda abc123: user_login_ids[abc123], users))
        group = c.create_group(group_cat_id, name)
        group_id = group['id']
        c.add_group_members(group_id, users)

    return 0

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
